# 个人设置

先根据前端`个人信息设置`要传的参数建表
```sql
CREATE TABLE `db_account_info` (
  `uid` bigint(20) NOT NULL,
  `sex` enum('male','female') DEFAULT NULL,
  `phone` varchar(255) DEFAULT NULL,
  `qq` varchar(255) DEFAULT NULL,
  `wx` varchar(255) DEFAULT NULL,
  `blog` varchar(255) DEFAULT NULL,
  `desc` text,
  PRIMARY KEY (`uid`),
  CONSTRAINT `uid` FOREIGN KEY (`uid`) REFERENCES `db_account` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

根据前端`隐私设置`要传的参数建表
```sql
CREATE TABLE `db_account_privacy` (
  `uid` bigint(20) NOT NULL,
  `email` smallint(6) DEFAULT NULL COMMENT '这些字段都用smallint，0表示关闭，1表示显示隐私',
  `sex` smallint(6) DEFAULT NULL,
  `phone` smallint(6) DEFAULT NULL,
  `wx` smallint(6) DEFAULT NULL,
  `qq` smallint(6) DEFAULT NULL,
  `blog` smallint(6) DEFAULT NULL,
  PRIMARY KEY (`uid`),
  CONSTRAINT `uid_p` FOREIGN KEY (`uid`) REFERENCES `db_account` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

## 个人信息设置

>1、将用户信息从数据库中读出，呈现到页面上
2、提交表单后，可以对数据库中的内容进行对应修改
3、前端做了校验，后端仍然要做校验

com/xiaoRed/controller/UserController.java
类添加`@Validated`注释才能使校验生效
```java
@PostMapping("/save-info")
    public RestBean<String> saveInfo(@RequestBody @Validated AccountInfo accountInfo,
                                   @SessionAttribute("accountUser") AccountUser accountUser){
        accountInfo.setUid(accountUser.getId());//将uid给到用户信息
        if(userService.saveUserInfo(accountInfo)){
            accountUser.setUsername(accountInfo.getUsername());//将Session中存的用户名也要改掉
            return RestBean.success();
        }else{
            return RestBean.failure(400,"用户名已存在，无法修改");
        }
    }

@GetMapping("/info")
    public RestBean<AccountInfo> info(@SessionAttribute("accountUser") AccountUser accountUser){
        return RestBean.success(userService.userInfo(accountUser.getId()));
    }
```

com/xiaoRed/entity/user/AccountInfo.java
```java
@Data
public class AccountInfo {
    //包含中英文，不含特殊字符的用户名的正则表达式
    private static final String USERNAME_REGEX = "^[a-zA-Z0-9\\u4e00-\\u9fa5]+$";
    long uid;
    @Pattern(regexp = USERNAME_REGEX)
    @Length(min=2, max=8)
    String username;
    String sex;
    @Length(max=11)
    String phone;
    @Length(max=11)
    String qq;
    @Length(max=30)
    String wx;
    @Length(max=50)
    String blog;
    @Length(max=500)
    String desc;
}
```

com/xiaoRed/service/UserService.java
```java
public interface UserService {
    boolean saveUserInfo(AccountInfo accountInfo);
    AccountInfo userInfo(long uid);
}

```

com/xiaoRed/service/impl/UserServiceImpl.java
```java
@Service
public class UserServiceImpl implements UserService {
    @Resource
    UserMapper userMapper;
    @Override
    public boolean saveUserInfo(AccountInfo accountInfo) {
        //根据提交的表单的用户名查找数据库中的用户
        Account account = userMapper.findAccountByNameOrEmail(accountInfo.getUsername());
        if(account==null) {//如果没有，那么可以正常改名
            userMapper.updateUsername(accountInfo.getUsername(), accountInfo.getUid());
        }else if(account.getId()!=accountInfo.getUid()){//如果有这个用户名，且并非当前账号，则不能改名，修改失败
            return false;
        }
        //正常修改信息：1、更改的用户名在数据库中不存在 2、虽存在，但是自己账户的，那也可以改
        userMapper.saveInfo(accountInfo);
        return true;
    }

    @Override
    public AccountInfo userInfo(long uid) {
        return userMapper.findInfoById(uid);
    }
}
```

com/xiaoRed/mapper/UserMapper.java
```java
@Insert(" insert into db_account_info(uid, sex, phone, qq, wx, blog, `desc`) " +
            "values(#{uid}, #{sex}, #{phone}, #{qq}, #{wx}, #{blog}, #{desc}) " +
            "on duplicate key update uid=#{uid}, sex=#{sex}, phone=#{phone}, " +
            "qq=#{qq},wx=#{wx},blog=#{blog},`desc`=#{desc}")//出现主键重复的时候，只用做更新即可，而不是插入
void saveInfo(AccountInfo accountInfo);

@Update("update db_account set username = #{name} where id = #{uid}")
void updateUsername(String name,long uid);

@Select("select * from db_account left join db_account_info on id = uid where id =#{uid}")
AccountInfo findInfoById(long uid);
```

**改个小bug：先判断session中没有用户，才会向session存用户信息（不然修改用户名后会有bug）**
com/xiaoRed/interceptor/AuthorizeInterceptor.java
```java
@Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        if(request.getSession().getAttribute("accountUser")==null){
            //从SecurityContext中拿到登录用户的用户信息
            SecurityContext context = SecurityContextHolder.getContext();
            Authentication authentication = context.getAuthentication();
            User user = (User) authentication.getPrincipal();
            String username = user.getUsername();
            AccountUser accountUser = userMapper.findAccountUserByNameOrEmail(username);//一定是可以查到的
            request.getSession().setAttribute("accountUser", accountUser);//往请求体里的session域里丢用户详细信息，让Controller层拿到它
        }
        return true;
    }
```

## 账号安全设置
>1、修改邮箱功能偷个懒，没有进行原邮箱验证，新邮箱验证，而是直接可以修改
2、对比数据库中密文存储的密码和前端传过来的输入的“原密码”，可以用`matches()`函数来判断
3、前端对输入进行校验，后端也要进行校验

com/xiaoRed/controller/UserController.java
```java
    //邮件地址的正则表达式
    private final String EMAIL_REGEX = "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+.[a-zA-Z]{2,}$";
    @PostMapping("/save-email")
    public RestBean<String> saveEmail(@Pattern (regexp = EMAIL_REGEX)@RequestParam("email") String email,
                                      @SessionAttribute("accountUser") AccountUser accountUser){
        if(userService.saveEmail(email,accountUser.getId())){
            accountUser.setEmail(email);//session中的也要进行相应修改
            return RestBean.success();
        }else{
            return RestBean.failure(400,"邮件地址已被其他用户使用，无法修改");
        }
    }

    @PostMapping("change-password")
    public RestBean<String> changePassword(@Length(min = 6, max =16) @RequestParam("old") String old_paw,
                                           @Length(min = 6, max =16) @RequestParam("new") String new_paw,
                                           @SessionAttribute("accountUser") AccountUser accountUser){
        if(userService.changePassword(old_paw, new_paw, accountUser.getId())){
            return RestBean.success();
        }else{
            return RestBean.failure(400, "原密码错误");
        }
    }
```

com/xiaoRed/service/UserService.java
```java
boolean saveEmail(String email, long uid);
boolean changePassword(String old_paw, String new_paw, long uid);
```

com/xiaoRed/service/impl/UserServiceImpl.java
```java
    @Override
    public boolean saveEmail(String email, long uid) {
        Account account = userMapper.findAccountByNameOrEmail(email);
        if (account == null) {//新邮箱地址没被用过，可以直接更新
            userMapper.updateEmail(email, uid);
        }else return account.getId()==uid;//如果新邮箱地址和自己原来的一样，则不用改且返回true；否则不能改，且返回false
        return true;
    }

    BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();
    @Override
    public boolean changePassword(String old_paw, String new_paw, long uid) {
        Account account = userMapper.findAccountById(uid);//通过uid找到当前用户
        //输入的原密码和在数据库中加密存储的密码如果匹配上，才能改密码
        if(encoder.matches(old_paw, account.getPassword())){
            //加密后再存储到数据库
            String encode = encoder.encode(new_paw);
            userMapper.updatePassword(encode, uid);
            return true;
        }else{//原密码输入错误，不能修改密码
            return false;
        }
    }
```

com/xiaoRed/mapper/UserMapper.java
```java
@Update("update db_account set email = #{email} where id = #{uid}")
void updateEmail(String email, long uid);

@Update("update db_account set password = #{encode} where id = #{uid}")
void updatePassword(String encode, long uid);

@Select("select * from db_account where id = #{uid}")
Account findAccountById(long uid);
```